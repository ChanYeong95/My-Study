## 동시성

- 대부분의 웹 서버는 여러 개의 요청을 동시에 수행할 수 있다.
    - 동시성은 데이터 정합성을 깨뜨릴 수 있다.


- 데이터베이스에서 동시성 이슈가 발생하는 패턴
    1. 공유 자원 조회
    2. 공유 자원 갱신
- 공유 자원에 대한 잠금을 획득하여 요청을 순서대로 처리하는 방법으로 해결할 수 있다.


- 동시성 이슈가 어려운 이유
    1. 로컬 환경에서 대부분 하나의 스레드로 테스트하기 때문에 이슈를 발견하기 어렵다.
    2. 이슈가 발생하더라도 오류가 발생하지 않을 수 있다.
    3. 코드에서 동시성 이슈가 명확히 드러나지 않을 수 있다.
    4. 동시성 문제는 항상 발생하지 않으며 발생 시점이 비결정적이다.

### 제어 방법

- Java
  ```markdown
  상호배제(Mutual Exclusion)
    - 하나의 코드 블록이 둘 이상의 스레드에 의해 동시에 실행되는 것을 방지한다.
  
  가시성(Visibility)
    - 한 스레드가 변경한 데이터가 다른 스레드에게 즉시 보이는 것을 보장한다.
  ```
    - 동기화(Synchronization)
        - `synchronized` 키워드를 통해 메소드나 코드 블록을 여러 스레드가 동시에 접근하는 것을 방지한다.
            - 상호배제와 가시성을 모두 지원
    - Volatile
        - `volatile` 키워드를 통해 변수의 읽기와 쓰기를 메인 메모리에서 직접 수행하게 함으로써 가시성을 보장한다.
        - 복합 연산에 대해서는 원자성을 보장하지 않는다.


- 분산환경
    - 분산 트랜잭션(Distributed transaction)
        - Tow-Phase Commit
            - 모든 서비스의 트랜잭션 성공을 확정하기 전에 두 단계(준비와 커밋 단계)를 거치는 방법
                - 속도가 느리다.
                - 모든 서비스에 LOCK IN이 걸려 교착 상태가 발생할 수 있다.
        - SAGA Pattern
            - 각 서비스에서 수행된 로컬 트랜잭션의 결과를 기반으로, 이벤트를 통해 다음 서비스의 트랜잭션을 트리거하고, 실패 시 보상 트랜잭션을 수행하여 일관성을 유지하는 방법
                - 서비스가 많아질 수 록 관리 포인트가 많아진다.
    - 분산 락(Distributed Lock)
        - 여러 서비스 간에 자원에 대한 접근을 동기화하기 위해 사용되는 락


- MySQL
    - 레코드 락(Record Lock)
        - 특정 레코드에 대한 잠금을 제공하여 해당 레코드에 대한 동시 변경을 방지한다.
        - MySQL에서는 테이블 레코드가 아닌 인덱스의 레코드를 잠근다.
        - 인덱스가 없다면 테이블의 모든 레코드에 락을 걸고, 테이블을 풀스캔하며 작업을 처리한다.
    - 갭 락(Gap Lock)
        - 레코드가 아닌, 레코드 간의 간격에 잠금을 걸어 새로운 레코드의 삽입을 제어합니다.
        - 이미 삽입된 레코드에 대한 팬텀 읽기가 발생할 수 있다.
    - 넥스트 키락(Next-Key Lock) 등장한 배경
        - 레코드 락과 갭 락을 복합적으로 적용하여 레코드와 그 앞의 갭에 잠금을 걸어 팬텀 읽기를 방지한다.

    - 외래키로 인한 잠금
        - 외래키 제약 조건으로 인해 발생하는 잠금
        - 관련된 모든 테이블에 대한 데이터 체크와 잠금으로 인해 성능 저하나 교착 상태가 발생할 수 있다.

    - 교착 상태(Dead Lock)
        - 둘 이상의 프로세스나 스레드가 서로 가진 자원들 기다리며 더 이상 진행할 수 없는 상태
        - 발생 시나리오
            - 동일 리소스에 대한 잠금 경쟁
            - 테이블 잠금 순서
            - 외래 키 제약 조건
            - 인덱스 스캔
