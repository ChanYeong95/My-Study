## 인덱스

> 탐색(검색) 범위를 최소화 하는 것

- 조회 최적화

  |     | 메모리             | 디스크     |
                        |-----|-----------------|---------|
  | 속도  | 빠름              | 느림      |
  | 영속성 | 전원이 공급되지 않으면 휘발 | 영속성이 있음 |
  | 영속성 | 비쌈              | 저렴함     |
    - 메모리에 적재된 데이터로 최대한 요청을 처리한다.
        - 메모리 캐시 히트율 높이는 것
        - 메모리 데이터 유실을 고려해 WAL(Write Ahead Log) 사용

- 데이터베이스 성능 최적화
  ```markdown
  - 랜덤 I/O
    - 무작위 위치의 데이터 I/O
  - 순차 I/O
    - 연속된 순서의 데이터 I/O
    
  대부분의 트랜잭션은 무작위 하게 Write가 발생한다.
  이를 지연시켜 랜덤 쓰기를 순차 쓰기로 변환하여 디스크 I/O 성능을 향상시킬 수 있다.
  ```
    - 디스크의 랜덤 I/O(접근)을 최소화하는 것이다.


- 인덱스
    - 정렬된 자료구조
    - 인덱스 테이블에서 키를 검색한 후, 해당하는 원본 데이터의 위치를 찾는다.
    - B+ Tree
        - 삽입/삭제 시 항상 균형을 이룬다.
        - 하나의 노드가 여러 개의 자식 노드를 가질 수 있다.
            - 트리의 높이를 줄여 탐색 속도를 향상시킬 수 있다.
        - 리프 노드에만 데이터가 존재한다.
            - 연속적인 데이터 접근에 유리하다.
        ```markdown
        - MySQL은 일반적으로 B+ 트리를 사용하여 인덱스를 관리한다.
        - B+ 트리의 리프 노드에 기본 키(PK; Primary Key)의 값과 실제 데이터를 가리키는 포인터를 저장한다.
        - PK 사이즈가 커지면 B+ 트리 리프 노드에 저장할 수 있는 키의 수가 줄어들고, 이로 인해 리벨런싱이 자주 발생한다.
      
      
        오라클의 경우 PK가 이닌 데이터의 주소값을 가지고 있다.
        ```

> 인덱스를 활용하면 조회 성능을 높일 수 있지만, 삽입/갱신 시 리벨런싱으로 인한 성능을 낮출 수 있다.

- 클러스터 인덱스
    - 데이터의 저장 위치를 결정하는 키값
    - PK를 활용한 검색이 빠르다.
        - 인덱스 키가 데이터의 물리적인 순서와 일치
        - 범위 검색에도 효과적이다.
    - MySQL의 PK는 클러스터 인덱스다.
        - 클러스터 키 순서에 따라서 데이터 저장 위치가 변경된다.
            - 삽입/갱신 시, 클러스터 키의 순서에 따라 데이터의 위치를 변경시켜 성능 이슈가 발생할 수 있다.
    - MySQL에서 PK를 제외한 모든 인덱스는 PK를 가지고 있다.
        - 세컨더리 인덱스만으로 원하는 데이터를 찾을 수 있다.
        - 커버링에 유리하다.

```markdown
PK Auto Increment vs UUID

- 장점
    - Auto Increment
        - 구현이 쉽다.
        - 항상 이전 레코드보다 큰 값을 가지므로 인덱싱에 효율적이다.
    - UUID
        - 예측이 불가능하다.
        - 전역적으로 고유한 값을 보장한다.
            - 여러 시스템 간의 병합이나 동기화 과정에서 충돌이 발생하지 않는다.

- 단점
    - Auto Increment
        - 여러 서버 간에 고유한 키 생성이 어렵다.
            - 분산 시스템에서의 확장성에 제약이 생길 수 있다.
    - UUID
        - 정렬이 불가능하다.
        - 용량이 크다.
```
