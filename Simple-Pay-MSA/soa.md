# SOA(Service Oriented Architecture)

- 처음 소프트웨어 아키텍처의 시작은 모놀리식
- 하지만 여기서 오는 고통들과 제한적인 환경에서나마 해결하위해 나온 아키텍처

## 모놀리식 아키텍처와 SOA

### 차이점

- 모놀리식
    - 하나의 어플리케이션이 하나의 서버에 배포
    - 단일 코드베이스
    - 싱글/멀티 모듈 방식으로 개발은 가능하지만, 근본적으로 하나의 프로세스
- SOA
    - **서비스** 단위로 개발하고, 서비스 간 규격화된 프로토콜(인터페이스)을 사용하여 통신
    - 대부분 동일한 기술 스택들을 가지고 서비스들을 개발하며, 각 서비스들간의 재사용이 목적
    - ESB(Enterprise Service Bus)라는 개념을 통해, 요청에 대해 어떤 서비스들을 호출할 지 캡슐화 된 Layer 존재
    - 서비스 간 통합을 강조

### 공통점

![image](https://github.com/user-attachments/assets/83a2b19f-6477-456b-9f09-6dfbc0942f5e)

- Shared DB 사용
- 대개 원 코드베이스
- 모듈/서비스 간 규격화된 호출 방식 사용 (서비스 간 통합 관점)
    - 모듈/서비스 간 강한 의존성, 결합도

#### SOA 만의 특징, 차이점

- 독립적으로 배포 가능
- 비즈니스 로직에 따라, 어떤 서비스를 호출할 지 결정하는 Layer 존재
- 트랜잭션 구현은 별개로 해야 한다.
- ESB의 관리 (Integration of Monolithic)
    - MSA 의 원칙을 정면으로 반박
- 동일 플랫폼(환경)에서 서비스 간 호출을 하다보니, 성능 이슈 존재

## SOA와 MSA

### 공통점

![image](https://github.com/user-attachments/assets/5d5a375e-267a-48e2-9074-4834f1016f7f)

- 개발의 단위를 **서비스**로 인지
- 다른 서비스와 독립적으로 개발, 배포 가능

#### MSA 만의 특징, 차이점

- 비즈니스 로직(서비스)의 재사용 지양
- 서비스 간 결합도를 낮추는 것이 목표
- 낮은 결합도로 변화에 애자일한 대응 가능
- 각 서비스는 각 서비스의 특성에 맞는 최적의 기술스택을 독립적으로 선택 가능
- 서비스 간 자유로운 방식(HTTP, gRPC, ...)으로 통신 가능
